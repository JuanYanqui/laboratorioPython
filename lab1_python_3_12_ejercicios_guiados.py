# -*- coding: utf-8 -*-
"""lab1_python_3_12_ejercicios_guiados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p-wsyuttWPu8JEH5WCavhoxMYPd_dfSb
"""

# =========================
# Módulo A — Funciones y Métodos
# =========================

# --- A.1: Funciones como valores ---
def saludar(nombre):
    return f"Hola, {nombre}"

def despedir(nombre):
    return f"Adiós, {nombre}"

def aplaudir(nombre):
    return f"Bien hecho, {nombre}"

# Diccionario de acciones
acciones = {
    "saludar": saludar,
    "despedir": despedir,
    "aplaudir": aplaudir
}

def ejecutar(accion, *args, **kwargs):
    if accion not in acciones:
        raise ValueError(f"La acción '{accion}' no está disponible.")
    funcion = acciones[accion]
    return funcion(*args, **kwargs)


# --- A.2: Funciones internas y closures ---
def crear_descuento(porcentaje):
    def aplicar_descuento(precio):
        return precio * (1 - porcentaje)
    return aplicar_descuento

descuento10 = crear_descuento(0.10)
descuento25 = crear_descuento(0.25)

# =========================
# Módulo B — Excepciones
# =========================

# --- B.1: Validación de entrada ---
def parsear_enteros(entradas):
    valores = []
    errores = []
    for elemento in entradas:
        try:
            valores.append(int(elemento))
        except ValueError:
            errores.append(f"'{elemento}' no es un entero válido")
    return valores, errores


# --- B.2: Excepciones personalizadas ---
class CantidadInvalida(Exception):
    pass

def calcular_total(precio_unitario, cantidad):
    if cantidad <= 0:
        raise CantidadInvalida(f"La cantidad debe ser mayor a 0. Recibido: {cantidad}")
    if precio_unitario < 0:
        raise ValueError(f"El precio unitario no puede ser negativo. Recibido: {precio_unitario}")
    return precio_unitario * cantidad

# =========================
# Módulo C — Decoradores
# =========================

# --- C.1: Decorador de validación ---
def requiere_positivos(func):
    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, (int, float)) and arg <= 0:
                raise ValueError(f"Todos los valores numéricos deben ser positivos. Recibido: {arg}")
        return func(*args, **kwargs)
    return wrapper

@requiere_positivos
def calcular_descuento(precio, porcentaje):
    return precio * (1 - porcentaje)

@requiere_positivos
def escala(valor, factor):
    return valor * factor

# --- A.1 ---
print(ejecutar("saludar", "Ana"))
print(ejecutar("despedir", "Luis"))
print(ejecutar("aplaudir", "Sofía"))

# --- A.2 ---
print(descuento10(100))
print(descuento25(80))

# --- B.1 ---
entradas = ["10", "x", "3"]
valores, errores = parsear_enteros(entradas)
print(valores)  # [10, 3]
print(errores)  # ["'x' no es un entero válido"]

# --- B.2 ---
try:
    print(calcular_total(10, 3))
    print(calcular_total(10, 0))
except CantidadInvalida as e:
    print(f"Error: {e}")
except ValueError as e:
    print(f"Error: {e}")

# --- C.1 ---
try:
   print(calcular_descuento(100, 0.2))
   print(calcular_descuento(-1, 0.2))
except ValueError as e:
    print(f"Error: {e}")

    print(escala(5, 3))  # 15